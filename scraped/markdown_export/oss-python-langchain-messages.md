# oss-python-langchain-messages

> Source: https://docs.langchain.com/oss/python/langchain/messages

- Role - Identifies the message type (e.g.
system
,user
) - Content - Represents the actual content of the message (like text, images, audio, documents, etc.)
- Metadata - Optional fields such as response information, message IDs, and token usage
Basic usage
The simplest way to use messages is to create message objects and pass them to a model when invoking.Text prompts
Text prompts are strings - ideal for straightforward generation tasks where you don’t need to retain conversation history.- You have a single, standalone request
- You don’t need conversation history
- You want minimal code complexity
Message prompts
Alternatively, you can pass in a list of messages to the model by providing a list of message objects.- Managing multi-turn conversations
- Working with multimodal content (images, audio, files)
- Including system instructions
Dictionary format
You can also specify messages directly in OpenAI chat completions format.Message types
- System message - Tells the model how to behave and provide context for interactions
- Human message - Represents user input and interactions with the model
- AI message - Responses generated by the model, including text content, tool calls, and metadata
- Tool message - Represents the outputs of tool calls
System Message
ASystemMessage
represent an initial set of instructions that primes the model’s behavior. You can use a system message to set the tone, define the model’s role, and establish guidelines for responses.
Human Message
AHumanMessage
represents user input and interactions. They can contain text, images, audio, files, and any other amount of multimodal content.
Text content
Message metadata
AI Message
AnAIMessage
represents the output of a model invocation. They can include multimodal data, tool calls, and provider-specific metadata that you can later access.
AIMessage
objects are returned by the model when calling it, which contains all of the associated metadata in the response. However, that doesn’t mean that’s the only place they can be created/ modified from.
Providers weight/contextualize types of messages differently, which means it is sometimes helpful to create a new AIMessage
object and insert it into the message history as if it came from the model.
Attributes
Attributes
Tool calls
When models make tool calls, they’re included in theAIMessage
:
Token usage
AnAIMessage
can hold token counts and other usage metadata in its usage_metadata
field:
Streaming and chunks
During streaming, you’ll receiveAIMessageChunk
objects that can be combined into a full message:
Tool Message
For models that support tool calling, AI messages can contain tool calls. Tool messages are used to pass the results of a single tool execution back to the model. Tools can generateToolMessage
objects directly. Below, we show a simple example. Read more in the tools guide.
Attributes
Attributes
artifact
field stores supplementary data that won’t be sent to the model but can be accessed programmatically. This is useful for storing raw results, debugging information, or data for downstream processing without cluttering the model’s context.Example: Using artifact for retrieval metadata
Example: Using artifact for retrieval metadata
content
contains text that the model will reference, an artifact
can contain document identifiers or other metadata that an application can use (e.g., to render a page). See example below:Content
You can think of a message’s content as the payload of data that gets sent to the model. Messages have acontent
attribute that is loosely-typed, supporting strings and lists of untyped objects (e.g., dictionaries). This allows support for provider-native structures directly in LangChain chat models, such as multimodal content and other data.
Separately, LangChain provides dedicated content types for text, reasoning, citations, multi-modal data, server-side tool calls, and other message content. See content blocks below.
LangChain chat models accept message content in the content
attribute, and can contain:
- A string
- A list of content blocks in a provider-native format
- A list of LangChain’s standard content blocks
content_blocks
when initializing a message will still populate message
content
, but provides a type-safe interface for doing so.Standard content blocks
LangChain provides a standard representation for message content that works across providers. Message objects implement acontent_blocks
property that will lazily parse the content
attribute into a standard, type-safe representation. For example, messages generated from ChatAnthropic or ChatOpenAI will include thinking
or reasoning
blocks in the format of the respective provider, but can be lazily parsed into a consistent ReasoningContentBlock
representation:
- Anthropic
- OpenAI
LC_OUTPUT_VERSION
environment variable to v1
. Or,
initialize any chat model with output_version="v1"
:Multimodal
Multimodality refers to the ability to work with data that comes in different forms, such as text, audio, images, and video. LangChain includes standard types for these data that can be used across providers. Chat models can accept multimodal data as input and generate it as output. Below we show short examples of input messages featuring multimodal data:Content block reference
Content blocks are represented (either when creating a message or accessing thecontent_blocks
property) as a list of typed dictionaries. Each item in the list must adhere to one of the following block types:
Core
Core
TextContentBlock
TextContentBlock
Multimodal
Multimodal
ImageContentBlock
ImageContentBlock
AudioContentBlock
AudioContentBlock
VideoContentBlock
VideoContentBlock
FileContentBlock
FileContentBlock
Tool Calling
Tool Calling
ToolCall
ToolCall
ToolCallChunk
ToolCallChunk
Server-Side Tool Execution
Server-Side Tool Execution
ServerToolCall
ServerToolCall
ServerToolCallChunk
ServerToolCallChunk
ServerToolResult
ServerToolResult
content
property, but rather a new property that can be used to access the content of a message in a standardized format.Use with chat models
Chat models accept a sequence of message objects as input and return anAIMessage
as output. Interactions are often stateless, so that a simple conversational loop involves invoking a model with a growing list of messages.
Refer to the below guides to learn more:
- Built-in features for persisting and managing conversation histories
- Strategies for managing context windows, including trimming and summarizing messages